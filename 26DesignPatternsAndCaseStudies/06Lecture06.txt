~~ factory pattern ~~

it is sometimes said that usage of new keyword is not good.

what problems does new keyword introduce ?
- our class starts to depend on concrete implementations. it violates DIP.
when a code starts depending on concrete class, we loose flexibility.

how to get rid of new keyword ?

- dependency injection.
when we do DI with polymorphic type then we can use the code in several ways.

public introduce Coffee {
    void brew();
    void boil();
}

public class Cappuccino implements Coffee {
    @Override
    public void brew();

    @Override
    public void boil();
}

public class Expresso implements Coffee {
    @Override
    public void brew();

    @Override
    public void boil();
}

public class Robusta implements Coffee {
    @Override
    public void brew();

    @Override
    public void boil();
}

public class CoffeeServer {
    public Coffee serve(string coffeeType) {
        Coffee coffee;
        if (coffeeType.equals("Cappuccino"))
            coffee = new Cappuccino();
        else if (coffeeType.equals("Expresso"))
            coffee = new Expresso();
        else if (coffeeType.equals("Robusta"))
            coffee = new Robusta();
        coffee.brew();
        coffee.boil();
        return coffee;
    }
}

It is not following OCP, doing just opposite, can't be extended, it can only be modified if new type of
coffee gets introduced.
and, CoffeeServer depends on 3 concrete classes. 

What we understand is, there is a tight binding between coffeeType and coffee object. We should not
confine it to CoffeeServer, as it maybe needed by other classes as well latter.

This type of scenario, where type is mapped down to an object is called 'creational responsibility'.

We need to keep this responsibility in a separate class and make it available to all. This is known as
factory pattern.

public class CoffeeFactory {
    public Coffee getCoffee(string coffeeType) {
        Coffee coffee;
        if (coffeeType.equals("Cappuccino"))
            coffee = new Cappuccino();
        else if (coffeeType.equals("Expresso"))
            coffee = new Expresso();
        else if (coffeeType.equals("Robusta"))
            coffee = new Robusta();
        return coffee;
    }
}

public class CoffeeServer {
    public Coffee serve(string coffeeType) {
        Coffee coffee = new CoffeeFactory.getCoffee(coffeeType);
        coffee.brew();
        coffee.boil();
        return coffee;
    }
}

DIP is important as it gives us flexibility to extend our classes.

coffee server
        |
    coffee          coffee-factory
    |   |
latte   capuchino

We are still dependent on concrete classes through CoffeeFactory, so to get away with it, we need to
create an interface for factory.

public interface AbstractFactory() {
    Coffee getCoffee(string coffeeType);
}

public class CoffeeFactory implements AbstractFactory {

    @Override
    public Coffee getCoffee(string coffeeType) {
        Coffee coffee;
        if (coffeeType.equals("Cappuccino"))
            coffee = new Cappuccino();
        else if (coffeeType.equals("Expresso"))
            coffee = new Expresso();
        else if (coffeeType.equals("Robusta"))
            coffee = new Robusta();
        return coffee;
    }
}

public class CoffeeServer {

    public final AbstractFactory factory;

    public CoffeeServer(AbstractFactory fact) {
        this.factory = fact;
    }

    public Coffee serve(string coffeeType) {
        Coffee coffee = new CoffeeFactory.getCoffee(coffeeType);
        coffee.brew();
        coffee.boil();
        return coffee;
    }
}
